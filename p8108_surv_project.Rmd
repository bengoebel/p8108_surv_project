---
title: "P8108 Group 2 Survival Analysis Project"
author: 
  - Yiming Zhao (yz3955) 
  - Wenshan Qu (wq2160)
  - Tucker Morgan (tlm2152)
  - Junzhe Shao (js5959)
  - Benjamin Goebel (bpg2118)
date: "2022-12-1"
output:
    pdf_document:
    latex_engine: xelatex
---

```{r setup, message=FALSE, warning = FALSE}
library(survival)
library(tidyverse)
library(tidymodels)
library(glmnet)
library(ranger)
library(survminer)
library(arsenal)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

## Train Validation Test Split
```{r train validation test split}
set.seed(2022)

rotterdam_split <- initial_split(select(rotterdam, -rtime, -recur, -pid), 
                                 prop = 0.8, strata = death)
rotterdam_training <- training(rotterdam_split)
rotterdam_test <- testing(rotterdam_split)

rotterdam_train_val_split <- initial_split(rotterdam_training, 
                                           prop = 0.8, strata = death)
rotterdam_training <- training(rotterdam_train_val_split)
rotterdam_validation <- testing(rotterdam_train_val_split)
```

## Perform 10-fold Cross-Validation  
The output contains 1 row for each fold/repeat. So, 10 folds * 5 repeats = 50
rows. The split_analysis column is a list column containing a data frame for
each row with 9 folds combined, and the split_assessment column is a list column 
containing a data frame for each row with 1 fold.
```{r cv}
set.seed(2022)

rotterdam_folds <- vfold_cv(rotterdam_training, v = 10, repeats = 5, 
                            strata = death)

rotterdam_folds <- rotterdam_folds %>%
  mutate(split_analysis = map(splits, analysis),
         split_assessment = map(splits, assessment))
```

## Introduction

## Methods

The dataset of interest for this analysis comes from the Rotterdam tumor bank, including data from `r nrow(rotterdam)` breast cancer patients. Follow up time for patients varied from just 1 month to as long as 231 months. Several prognostic variables are recorded including year of surgery, age at surgery, menopausal status (pre- or post-), tumor size (mm), differentiation grade, number of positive lymph nodes, progesterone receptors (fmol/l), estrogen receptors (fmol/l), and indicators for hormonal treatment and chemotherapy treatment. The outcome considered in this analysis was patient death.

(Placeholder for Cross-validation)

As part of this analysis, we consider the Cox Proportional Hazard (Cox PH) model, which allows us to model the hazard ratio based on covariates to understand their impact on the survival function. The Cox PH typically takes the form:
$$h(t|Z = z) = h_0(t)e^{\beta'z}.$$

In this application, we use the elastic net penalty, a mixture of the $\ell_1$ and $\ell_2$ norm regularization penalties. In the Cox PH framework, this penalty term takes the form of:
$$\lambda\Big(\alpha \sum |\beta_i| + \frac{1}{2}(1 - \alpha)\sum\beta_i^2\Big)$$
where $\lambda$ represents our penalty coefficient and $\alpha$ is the mixing parameter for the two regularization methods. This penalty helps to avoid over-fitting of our data. The algorithm used here in `glmnet` uses the Breslow approximation to handle ties. For more details on the derivation of this term and the algorithm used to fit the penalized Cox PH model, see Simon et al. (2011).

## Exploratory Data Analysis
```{r results='asis'}
print(summary(tableby(hormon~age+meno+size+grade+nodes+pgr+er+chemo+dtime+death,
                      rotterdam,numeric.simplify = TRUE, numeric.test = "kwt")))

```
## Cross-Validation

## Cox/Cox with elastic net

```{r cox elastic net}
set.seed(2022)

cox_trn_x <- model.matrix(Surv(dtime, death) ~ ., rotterdam_training)[,-1]
cox_trn_y <- Surv(rotterdam_training$dtime, rotterdam_training$death)

cv_coxfit <- cv.glmnet(cox_trn_x, cox_trn_y, family = "cox", type.measure = "deviance")

par(mar = c(4,4,5,1))
plot(cv_coxfit, main = "Cross-Validated Error Plot")

coxnetfit <- glmnet(cox_trn_x, cox_trn_y, family = "cox", alpha = 1)

par(mar = c(4,4,5,1))
plot(coxnetfit, xvar = "lambda",
     main = "Cox PH Elastic Net Coefficients")
abline(v = log(cv_coxfit$lambda.min), lty = 2)

coxnetfit_df <- 
  data.frame(
    "coef" = as.vector(coef(coxnetfit, s = cv_coxfit$lambda.min)),
    "exp_coef" = as.vector(coef(coxnetfit, s = cv_coxfit$lambda.min)) %>% exp()
)

rownames(coxnetfit_df) <- labels(coef(coxnetfit, s = cv_coxfit$lambda.min))[[1]]

coxnetfit_df %>% round(digits = 4) %>% 
  knitr::kable(caption = "Cox Proportion Hazard Elastic Net Coefficients")
```

In the table above, we can see that estrogen receptors and chemotherapy are selected out with a null value of 0 or $\exp(coef) = 1$. We can fit a cox proportional hazard model using only the selected covariates in the `coxph` function to find unbiased estimates of the coefficients along with standard errors and confidence intervals. 

```{r coxph confint}
coxfit <- coxph(Surv(dtime, death) ~ year + age + meno + size + grade + 
                  nodes + pgr + hormon,
                data = rotterdam_training, ties = "breslow")
coxfit %>% 
  broom::tidy() %>% 
  mutate(estimate = exp(estimate))

confint(coxfit) %>% exp() %>% knitr::kable()
```

In our (minimum error) model, we find significant effects for year of surgery, age at surgery, size of tumor, differentiation grade, number of positive lymph nodes, and progesterone receptors. The largest magnitude effects come from increasing size of tumor.

Below, we see the analogous results for a "1se" rule model.

```{r cox elastic net 1se}
par(mar = c(4,4,5,1))
plot(coxnetfit, xvar = "lambda",
     main = "Cox PH Elastic Net Coefficients")
abline(v = log(cv_coxfit$lambda.1se), lty = 2)

coxnetfit_1se_df <- 
  data.frame(
    "coef" = as.vector(coef(coxnetfit, s = cv_coxfit$lambda.1se)),
    "exp_coef" = as.vector(coef(coxnetfit, s = cv_coxfit$lambda.1se)) %>% exp()
)

rownames(coxnetfit_1se_df) <- labels(coef(coxnetfit, s = cv_coxfit$lambda.1se))[[1]]

coxnetfit_1se_df %>% round(digits = 4) %>% 
  knitr::kable(caption = "Cox Proportion Hazard Elastic Net Coefficients (1se)")
```

Here, we remove `meno`, `er`, `hormon` and `chemo` and find the following results.

```{r coxph 1se confint}
coxfit_1se <- coxph(Surv(dtime, death) ~ year + age + size + grade + nodes + pgr,
                data = rotterdam_training, ties = "breslow")
coxfit_1se %>% 
  broom::tidy() %>% 
  mutate(estimate = exp(estimate))

confint(coxfit_1se) %>% exp() %>% knitr::kable()
```

Here we again find significant effects for year of surgery, age at surgery, size of tumor, differentiation grade, number of positive lymph nodes, and pgr.

## Random survival forest

The survival tree and the corresponding random survival forest (RSF) are highly favorable non-parametric methods when studying survival data. Generally, for a single survival tree, it will assign subjects to groups based on certain splitting rules regarding their covariates, and the subjects in each group will share a similar survival behavior.

```{r}
set.seed(2023)
## Random Survival Forest
rsf <- ranger(Surv(time = dtime, event = death) ~ ., 
              data = rotterdam_training, 
              num.trees = 300, 
              min.node.size = 15)

## Remove variables not for prediction, and the outcome
rotterdam_test_d <- 
  rotterdam_test %>% 
  select(-death)

## Make prediction on all the test data points
pred_rsf <- predict(rsf, rotterdam_test_d, type = "response")
# Look at individual 7
pred_ref_7 <- data.frame(
  time = pred_rsf$unique.death.times,
  survival = pred_rsf$survival[7,])
head(pred_ref_7) %>% knitr::kable(align = "c")

plot(pred_ref_7$time, pred_ref_7$survival, 
     xlab = "Time", ylab = "Survival Probability",
     main = "Survival Prediction for Patient 7")
# Find estimated median survival time for individual 7
head(pred_ref_7[pred_ref_7$survival <= 0.5,]) %>% knitr::kable(align = "c") #1163
# See the truth of individual 7
rotterdam_test[7,] %>% knitr::kable(align = "c")
```

With `ranger` package, we trained the random survival forest with training dataset used for survival prediction. As a non-parametric method, there is no parameters in RSF that could be interpreted. The ultimate goal of RSF is to predict the survival probability function of a given data point based on its covariate vector. Compared to semi-parametric Cox-PH model which forces the outcome and the covariates to have a special connection, the RSF makes prediction based on the survival time of training data points that shares similar propensity with the given input data point.

Since the "truth" of test data point (a single survival time) and the prediction we made here (a survival probability function) are not comparable, here we show the prediction result of the 7th test data point (pid = 58). The survival curve has been shown above, and the median survival time is 1163 days.  

## Comparison of Cox Proportional-Hazards Elastic Net with Random Survival Forest  
We compared the Cox proportional-hazards elastic net model with the random 
survival forest by calculating the Brier score for each model on the validation 
set. The formula for the Brier score is as follows.
\begin{align*}
BS = \frac{1}{n} \sum_{i=1}^n (p_i - o_i)^2
\end{align*}
The Brier score is used to evaluate the accuracy of probabilistic predictions
from a model; its value ranges from 0 to 1 with 0 being perfect and 1 being the 
opposite. We calculated the Brier score using the validation set. For each
observation in the validation set, predictions were made at the observed time
of censoring or event. Our analysis proceeds as follows.  

First, we calculated the Brier score for the Cox proportional-hazards
elastic net model.  
```{r}
# Purpose: Calculates the Brier score for the Cox proportional-hazards elastic
#          net model.
# Arguments: fit: The Cox proportional-hazards elastic net model.
#            train: A dataframe, the training data used to fit the model.
#            test: A dataframe, the data to use to calculate the Brier score.
# Returns: A double, the Brier score. 
brier_coxnet <- function(fit, train, test) {
  train_x <- model.matrix(Surv(dtime, death) ~ ., train)[,-1]
  train_y <- Surv(pull(train, dtime), pull(train, death))
  test_x <- model.matrix(Surv(dtime, death) ~ ., test)[,-1]
  test_y <- pull(test, death)
  num_obs <- nrow(test_x)
  p <- vector(mode = "double", length = num_obs)
  for(i in 1:num_obs) {
    surv_fit <- survival::survfit(fit, s = cv_coxfit$lambda.min, 
                                  x = train_x, 
                                  y = train_y, 
                                  newx = test_x[i, ])
    time_index <- tail(which(surv_fit$time <= test[i, "dtime"]), n = 1)
    p[i] <- 1 - surv_fit$surv[time_index]
  }
  return(DescTools::BrierScore(resp = test_y, pred = p))
}
(brier_coxnet <- round(brier_coxnet(coxnetfit, rotterdam_training, rotterdam_validation), 3))
```

The Brier score for the Cox elastic net model is `r brier_coxnet`.  

Second, let's calculated the Brier score for the random survival forest model.  
```{r}
# Purpose: Calculates the Brier score for the random survival forest model.
# Arguments: fit: The random survival forest model.
#            df: A dataframe, the data to use to calculate the Brier score.
# Returns: A double, the Brier score. 
brier_ranger <- function(fit, df) {
  x <- df
  pred <-  predict(fit, data = x)
  num_obs <- nrow(df)
  p <- vector(mode = "double", length = num_obs)
  for(i in 1:num_obs) {
    time_index <- tail(which(pred$unique.death.times <= x[i, "dtime"]), n = 1)
    p[i] <- 1 - pred$survival[i, time_index]
  }
  return(DescTools::BrierScore(resp = df$death, pred = p))
}
(brier_ranger <- round(brier_ranger(rsf, rotterdam_validation), 3))
```

The Brier score for the random survival forest model is `r brier_ranger`. The
two models have very similar Brier scores.  

## Conformalized survival analysis

## Supplemental analyses

### Kaplan-Meier Survival Estimate
```{r}
KM = survfit(Surv(dtime, death) ~ 1, data = rotterdam)
plot(KM, conf.int = FALSE, mark.time = TRUE,
     xlab = "Days", ylab = "Survival Probability",
     main = "Kaplan-Meier Survival Estimate", cex.lab = 1.5, cex.main = 1.5)
```

```{r}
# make Kaplan-Meier estimates
kmfit <- survfit(Surv(dtime, death) ~ hormon, data = rotterdam,type=c("kaplan-meier"))
# print Kaplan-Meier table 
#summary(kmfit)
```

```{r}
plot(kmfit,
ylab="S(t)",
xlab="days to death or last follow-up",
main = "Kaplan Meier estimates of Breast cancer survival by hormonal treatment assignments for rotterdam data",
col = c("blue","red"))

ggsurvplot(kmfit, conf.int = 0.95, censor= F,title = " KM survival by hormonal treatment assignments",
           ggtheme = theme_minimal())
```


### Log-rank Test

The null hypothesis of our log-rank test is: $H_0: S_1(t) = S_0(t)$, where $S_1(t)$ is the survival function of hormon treatment group, $S_0(t)$ is the survival function of control group.

```{r}
logrank <- survdiff(Surv(dtime, death) ~ hormon, data = rotterdam)
logrank
logrank$pvalue
```

The test statistic is 23.7, and the corresponding p-value is $1.133^{-6} \ll 0.05$, thus we reject the null and conclude that we are 95% confident that $S_1(t) \ne S_0(t$. And since the test statistic is positive, we can conclude that the hormon treatment is significantly effective to breast cancer.

```{r}
ggsurvplot(survfit(Surv(dtime,death) ~ hormon, data = rotterdam), 
           conf.int = TRUE,
           legend = c("bottom"),
           legend.title = c("Treatment"),
           legend.labs = c("hormon", "control")) +
  ggtitle("Survival Curve of Hormon and Control group")
```


## Results

## Discussion

## How our results compare with past research

## Conclusion

\newpage

## References

---Note this reference is in MLA format---

Simon, Noah et al. “Regularization Paths for Cox's Proportional Hazards Model via Coordinate Descent.” Journal of statistical software vol. 39,5 (2011): 1-13. doi:10.18637/jss.v039.i05